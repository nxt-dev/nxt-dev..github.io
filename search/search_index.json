{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is nxt? NXT, pronounced \u025bn\u00b7\u025bks\u00b7ti, is a layered code compositing application. Enabling visualization of complex scripts and easy cross discipline collaboration. It\u2019s code with layers with a nice way to see and change data. How do I get it? pip pip install nxt-editor zip Download the latest nxt_<dccName>.zip from our GitHub releases page . Follow the instruction in the README inside that zip. special See here Platform Python 2 Python 3 Linux pip pip Mac pip pip Windows special pip Maya zip Where do I ask questions or report a bug? Head over to our GitHub Discussions to ask questions, get help, or report a bug. If you're confident you found a bug and are familur with GitHub you can report a core bug here or an editor bug here . Concepts Tutorials See concepts for a quick overview of nxt's core concepts. See the tutorials for a step by step walkthroughs. Questions Contributing Ask questions on our GitHub Discussions . See the contributing documentation for nxt or nxt editor .","title":"Home"},{"location":"#what-is-nxt","text":"NXT, pronounced \u025bn\u00b7\u025bks\u00b7ti, is a layered code compositing application. Enabling visualization of complex scripts and easy cross discipline collaboration. It\u2019s code with layers with a nice way to see and change data.","title":"What is nxt?"},{"location":"#how-do-i-get-it","text":"pip pip install nxt-editor zip Download the latest nxt_<dccName>.zip from our GitHub releases page . Follow the instruction in the README inside that zip. special See here","title":"How do I get it?"},{"location":"#where-do-i-ask-questions-or-report-a-bug","text":"Head over to our GitHub Discussions to ask questions, get help, or report a bug. If you're confident you found a bug and are familur with GitHub you can report a core bug here or an editor bug here .","title":"Where do I ask questions or report a bug?"},{"location":"about/","text":"Introduction The primary function of nxt is to visualize and automate programming tasks related to computer graphics and linear processing. The intent is to bridge the gap between one-off scripting and general purpose tools through the use of inheritance, layering, and string tokens. Why use nxt? The core functionality of nxt was built with insights from industry veterans of various technical and artistic backgrounds. We set out to bring to the table a simple set of principles: Visualize a map of what a complex script is actually doing. Nodes , inheritance , and connection lines are easy to understand. However, we've gone a step further and added string tokens . An instant visualization of what an attribute value actually is. Our tokens can be used almost anywhere inside nxt and are dynamically \"resolved\" during execution. Allowing the user to see exactly what data is flowing around without the use of an external debugger. Encourage collaboration though layering and multi context graphs. With our layering system it is easy for departments to share base workflows and utility nodes. Since layering is non-destructive graphs can referenced built on without worrying about breaking someone else's graph. With multi context graphs a Maya user, for example, can directly call a Houdini graph from inside Maya. Alternatively, graphs can call other graphs in the same context, allowing interdependent graphs to be developed simultaneously. Make code accessible to everyone. Artists can modify attributes like their used to and learn to make simple code changes that normally would require a TD to intervene. We're not visual programming, but rather a friendly visual portal into code. What does nxt do? In the simplest of terms nxt combines multiple layers of nodes into a single composite layer that is then executable. Something like Photoshop layers for your code, you're able to mute, solo, override, and extend layers of code. The resulting composite of the code clearly visualizes where attributes and their values came from. Colors, node paths, and conveniently placed buttons/links allow users to quickly jump to and correct erroneous values. Example character rig with a general to specific layer structure Limitations We currently do not support asynchronous execution in a single graph. Our current focus is on lineal scripts. We are not visual programming , no for loop nodes sorry. We currently experimentally support Python 3, it is possible to lose layout and break point preferences by switching back and forth between Py2/3. Special Thanks Sunrise Productions We would like to thank Sunrise Productions for providing us a studio incubator for 2019 and 2020. Sunrise kept food on the table and believed in nxt before it was fully realized. Without their support we would never have made it this far. SVAD Productions We would like to thank the School of Visual Art and Design NXT began in 2017 as a research project at SVAD. Originally with the goal to make it the core rigging framework, nxt quickly grew into the backbone of pipeline. We are grateful for SVAD providing the resources, education, and sponsorship to get us started. Walt Yoder mGear (Miquel Campos) Matt Schiller The nxt contributors Lucas Brown - Developer Michael Aldrich - Developer Aaron Adams - Visionary & Founder Zach Gray - Contributor","title":"About"},{"location":"about/#introduction","text":"The primary function of nxt is to visualize and automate programming tasks related to computer graphics and linear processing. The intent is to bridge the gap between one-off scripting and general purpose tools through the use of inheritance, layering, and string tokens.","title":"Introduction"},{"location":"about/#why-use-nxt","text":"The core functionality of nxt was built with insights from industry veterans of various technical and artistic backgrounds. We set out to bring to the table a simple set of principles: Visualize a map of what a complex script is actually doing. Nodes , inheritance , and connection lines are easy to understand. However, we've gone a step further and added string tokens . An instant visualization of what an attribute value actually is. Our tokens can be used almost anywhere inside nxt and are dynamically \"resolved\" during execution. Allowing the user to see exactly what data is flowing around without the use of an external debugger. Encourage collaboration though layering and multi context graphs. With our layering system it is easy for departments to share base workflows and utility nodes. Since layering is non-destructive graphs can referenced built on without worrying about breaking someone else's graph. With multi context graphs a Maya user, for example, can directly call a Houdini graph from inside Maya. Alternatively, graphs can call other graphs in the same context, allowing interdependent graphs to be developed simultaneously. Make code accessible to everyone. Artists can modify attributes like their used to and learn to make simple code changes that normally would require a TD to intervene. We're not visual programming, but rather a friendly visual portal into code.","title":"Why use nxt?"},{"location":"about/#what-does-nxt-do","text":"In the simplest of terms nxt combines multiple layers of nodes into a single composite layer that is then executable. Something like Photoshop layers for your code, you're able to mute, solo, override, and extend layers of code. The resulting composite of the code clearly visualizes where attributes and their values came from. Colors, node paths, and conveniently placed buttons/links allow users to quickly jump to and correct erroneous values. Example character rig with a general to specific layer structure","title":"What does nxt do?"},{"location":"about/#limitations","text":"We currently do not support asynchronous execution in a single graph. Our current focus is on lineal scripts. We are not visual programming , no for loop nodes sorry. We currently experimentally support Python 3, it is possible to lose layout and break point preferences by switching back and forth between Py2/3.","title":"Limitations"},{"location":"concepts/","text":"Concept quick start Nodes Graphs are made of node hierarchies. Node hierarchies can be collapsed by double clicking. During execution, a root node is executed, then it's descendants are executed depth first, then the next root node is begun. Execution sequencing between nodes is done via a special attribute: \"Exec Input\" where a node specifies the root node that is before it in execution. In the above example, the execution order would be: /parent , /parent/child1 , /parent/child1/child2 , /parent/sibling , /parent/sibling2 , /node , /node/node Attributes Rather than building a custom UI to interact with code, you edit attributes on nodes in a familiar property editor. Nxt substitutes attributes into the body of the code on the fly and generates linearly executed bespoke programs. It lets you interact via properties without writing, managing, and extracting data from a UI. All of this to print a value Less Attributes can refer to other attributes and are composited on the fly, or attributes can be used directly in code. These are called tokens . Inheritance Each tree inherits all the attributes of their parent nodes. (All of this can be easily hidden via 1,2,3 hotkeys) Those attributes are available to child nodes. Each child node can overwrite the value, or use the inherited value. Layers Nxt also incorporates a layering model where attributes and code can be overridden by nodes on higher layers and leave the underlying structure intact. Instances Finally, any node can be instanced and overridden by layers or nodes. Instancing allows you to reuse node trees from other parts of the graph with specific overrides.","title":"Concepts"},{"location":"concepts/#concept-quick-start","text":"","title":"Concept quick start"},{"location":"concepts/#nodes","text":"Graphs are made of node hierarchies. Node hierarchies can be collapsed by double clicking. During execution, a root node is executed, then it's descendants are executed depth first, then the next root node is begun. Execution sequencing between nodes is done via a special attribute: \"Exec Input\" where a node specifies the root node that is before it in execution. In the above example, the execution order would be: /parent , /parent/child1 , /parent/child1/child2 , /parent/sibling , /parent/sibling2 , /node , /node/node","title":"Nodes"},{"location":"concepts/#attributes","text":"Rather than building a custom UI to interact with code, you edit attributes on nodes in a familiar property editor. Nxt substitutes attributes into the body of the code on the fly and generates linearly executed bespoke programs. It lets you interact via properties without writing, managing, and extracting data from a UI. All of this to print a value Less Attributes can refer to other attributes and are composited on the fly, or attributes can be used directly in code. These are called tokens .","title":"Attributes"},{"location":"concepts/#inheritance","text":"Each tree inherits all the attributes of their parent nodes. (All of this can be easily hidden via 1,2,3 hotkeys) Those attributes are available to child nodes. Each child node can overwrite the value, or use the inherited value.","title":"Inheritance"},{"location":"concepts/#layers","text":"Nxt also incorporates a layering model where attributes and code can be overridden by nodes on higher layers and leave the underlying structure intact.","title":"Layers"},{"location":"concepts/#instances","text":"Finally, any node can be instanced and overridden by layers or nodes. Instancing allows you to reuse node trees from other parts of the graph with specific overrides.","title":"Instances"},{"location":"extensions/","text":"Extensions NXT can easily extended to better meet a user's/studio's needs. In this section you will find examples of how to use NXT's configuration and plugin system. If you're looking for a quick test and not trying to dive too deep, we have an almost drag and drop example Maya context here . Simple Remote Context In Maya simply navigate to the nxt menu and select \"Create Maya Context\". You'll be prompted to enter a name, the name you enter will be how you call your custom Maya context. For more on using custom contexts see here . In depth explanations: Config dir Custom configurations are graphs and code that extends or alters the functionality of nxt. Cofigs are not to be confused with preferences which are solely UX related. To add a config there are two approaches, both of which are compatible with eachother. Local config Config directory location: ~/nxt/config/<major_api_version> 2- Site config Site config directory can be set via an environment variable. NXT_SITE_DIR=/path/to/site_config Inside the config dir you'll need a directory called plugins . So for example if you're using API v0.1.2 your local config plugins dir would be: ~/nxt/config/0/plugins Plugins Any .py files inside your plugin dir(s) will automatically be imported during nxt startup. Creating Custom Contexts (Automatically) Note You will need to create your own context_graph see below for how to do that. import nxt nxt.create_context('MyContext', interpreter_exe='/path/to/python/executable/SpecialPython.exe', context_graph='SpecialPython_context.nxt') Creating Custom Contexts (Manually) It is possible to execute graphs in \"remote contexts,\" for example it one may want to execute a graph in a headless Maya session. These remote contexts can easilly be configured by users and TDs, this section will provide some examples on how to go about writing your own custom context plugin. Below is an exmaple of creating a custom Maya context. This code is an example to get you started, its not the only way to do things. Files we'll be creating: Plugins |_ my_custom_contexts.py |_ maya_2020_context.nxt my_custom_contexts.py The following example is for Maya 2020 running on Windows. The two imports from nxt that you'll need are the RemoteContext class and register_context function. The first arg in RemoteContexts is the context name , this will be used by users to call your context. Next we have the context executable, this must be a python (currently only Python 2.7 ) executable. And finally the path to your context graph. # Builtin import os # External from nxt.remote.contexts import RemoteContext, register_context # Maya 2020 maya2020_name = 'maya2020' maya2020_exe = 'C:/Program Files/Autodesk/Maya2020/bin/mayapy.exe' maya2020_graph = os.path.abspath(os.path.join(os.path.dirname(__file__), 'maya_2020_context.nxt')) maya_2020_context = RemoteContext(maya2020_name, maya2020_exe, maya2020_graph) register_context(maya_2020_context) maya_2020_context.nxt Now to write your context graph. 1) Create an nxt graph and make sure to add the following reference layer: \"references\": [ \"$NXT_BUILTINS/_context.nxt\" ] Note To add a layer like this (using the env var) right click on your layer in the layer manager and select Reference Builtin Graph 2) On the / node add an attr called maya_inst_name and set its value to nxt 3) Also on the / node we're going to want to write some custom code in. Add the following to the code block. cwd = os.path.dirname(sys.executable) python_home = os.path.abspath(os.path.join(cwd, '..', 'Python/Lib/site-packages')) sys.path.insert(0, python_home) from maya import standalone This will add the Maya site-packages to your environment and import maya.standalone . 4) In the /enter/init node you'll want to add your own custom code, something like this: STAGE.old_cwd = os.getcwd() maya_cwd = os.path.dirname(sys.executable) os.chdir(maya_cwd) standalone.initialize(name='${maya_inst_name}') 5) In the /enter/teardown node you want to uninitialize Maya, add the following code: standalone.uninitialize(name='${maya_inst_name}') os.chdir(STAGE.old_cwd) Using Custom Contexts From inside a graph Make sure your graph has this reference layer: $NXT_BUILTINS/remote_contexts.nxt Create a node, lets call it run_in_maya\" Set your new node's instance path to /_remote_sub_graph Set the _context attr to the raw context name you have access to or just created. Set the _graph_path attr to the path to a graph that you wish to run in the remote context. Note: Any other attributes on or inherited by your node /run_in_maya will be inherited by the / node of your remote graph. From api/cli nxt exe /path/to/graph.nxt --context maya2020 or import nxt nxt.execute_graph('/path/to/graph.nxt' context='maya2020')","title":"Extensions"},{"location":"extensions/#extensions","text":"NXT can easily extended to better meet a user's/studio's needs. In this section you will find examples of how to use NXT's configuration and plugin system. If you're looking for a quick test and not trying to dive too deep, we have an almost drag and drop example Maya context here .","title":"Extensions"},{"location":"extensions/#simple-remote-context","text":"In Maya simply navigate to the nxt menu and select \"Create Maya Context\". You'll be prompted to enter a name, the name you enter will be how you call your custom Maya context. For more on using custom contexts see here .","title":"Simple Remote Context"},{"location":"extensions/#in-depth-explanations","text":"","title":"In depth explanations:"},{"location":"extensions/#config-dir","text":"Custom configurations are graphs and code that extends or alters the functionality of nxt. Cofigs are not to be confused with preferences which are solely UX related. To add a config there are two approaches, both of which are compatible with eachother. Local config Config directory location: ~/nxt/config/<major_api_version> 2- Site config Site config directory can be set via an environment variable. NXT_SITE_DIR=/path/to/site_config Inside the config dir you'll need a directory called plugins . So for example if you're using API v0.1.2 your local config plugins dir would be: ~/nxt/config/0/plugins","title":"Config dir"},{"location":"extensions/#plugins","text":"Any .py files inside your plugin dir(s) will automatically be imported during nxt startup.","title":"Plugins"},{"location":"extensions/#creating-custom-contexts-automatically","text":"Note You will need to create your own context_graph see below for how to do that. import nxt nxt.create_context('MyContext', interpreter_exe='/path/to/python/executable/SpecialPython.exe', context_graph='SpecialPython_context.nxt')","title":"Creating Custom Contexts (Automatically)"},{"location":"extensions/#creating-custom-contexts-manually","text":"It is possible to execute graphs in \"remote contexts,\" for example it one may want to execute a graph in a headless Maya session. These remote contexts can easilly be configured by users and TDs, this section will provide some examples on how to go about writing your own custom context plugin. Below is an exmaple of creating a custom Maya context. This code is an example to get you started, its not the only way to do things. Files we'll be creating: Plugins |_ my_custom_contexts.py |_ maya_2020_context.nxt","title":"Creating Custom Contexts (Manually)"},{"location":"extensions/#my_custom_contextspy","text":"The following example is for Maya 2020 running on Windows. The two imports from nxt that you'll need are the RemoteContext class and register_context function. The first arg in RemoteContexts is the context name , this will be used by users to call your context. Next we have the context executable, this must be a python (currently only Python 2.7 ) executable. And finally the path to your context graph. # Builtin import os # External from nxt.remote.contexts import RemoteContext, register_context # Maya 2020 maya2020_name = 'maya2020' maya2020_exe = 'C:/Program Files/Autodesk/Maya2020/bin/mayapy.exe' maya2020_graph = os.path.abspath(os.path.join(os.path.dirname(__file__), 'maya_2020_context.nxt')) maya_2020_context = RemoteContext(maya2020_name, maya2020_exe, maya2020_graph) register_context(maya_2020_context)","title":"my_custom_contexts.py"},{"location":"extensions/#maya_2020_contextnxt","text":"Now to write your context graph. 1) Create an nxt graph and make sure to add the following reference layer: \"references\": [ \"$NXT_BUILTINS/_context.nxt\" ] Note To add a layer like this (using the env var) right click on your layer in the layer manager and select Reference Builtin Graph 2) On the / node add an attr called maya_inst_name and set its value to nxt 3) Also on the / node we're going to want to write some custom code in. Add the following to the code block. cwd = os.path.dirname(sys.executable) python_home = os.path.abspath(os.path.join(cwd, '..', 'Python/Lib/site-packages')) sys.path.insert(0, python_home) from maya import standalone This will add the Maya site-packages to your environment and import maya.standalone . 4) In the /enter/init node you'll want to add your own custom code, something like this: STAGE.old_cwd = os.getcwd() maya_cwd = os.path.dirname(sys.executable) os.chdir(maya_cwd) standalone.initialize(name='${maya_inst_name}') 5) In the /enter/teardown node you want to uninitialize Maya, add the following code: standalone.uninitialize(name='${maya_inst_name}') os.chdir(STAGE.old_cwd)","title":"maya_2020_context.nxt"},{"location":"extensions/#using-custom-contexts","text":"","title":"Using Custom Contexts"},{"location":"extensions/#from-inside-a-graph","text":"Make sure your graph has this reference layer: $NXT_BUILTINS/remote_contexts.nxt Create a node, lets call it run_in_maya\" Set your new node's instance path to /_remote_sub_graph Set the _context attr to the raw context name you have access to or just created. Set the _graph_path attr to the path to a graph that you wish to run in the remote context. Note: Any other attributes on or inherited by your node /run_in_maya will be inherited by the / node of your remote graph.","title":"From inside a graph"},{"location":"extensions/#from-apicli","text":"nxt exe /path/to/graph.nxt --context maya2020 or import nxt nxt.execute_graph('/path/to/graph.nxt' context='maya2020')","title":"From api/cli"},{"location":"hotkeys/","text":"Application Actions Name What's this Tool tip Shortcut Find Node Search for, select, and focus nodes in the view Find Node / New Graph New empty graph. New Graph Ctrl+N Open Graph Open nxt file. Open Graph Ctrl+O Undo Undo last command. Undo Ctrl+Z Redo Redo last command. Redo Ctrl+Shift+Z Layer Manager Toggle the layer manager widget. Layer Manager Property Editor Toggle the property editor widget. Property Editor Code Editor Toggle the code editor widget. Code Editor History View Toggle the history view widget. History View Build View Toggle the build view widget. Build View Output Log Toggle the output log widget. Output Log Hotkey Editor Toggle the hotkey editor widget. Hotkey Editor Workflow Tools Workflow tools dock widget. Workflow Tools Exit Close nxt. Exit Alt+F4 Open Last Closed Open previously closed file(s) Open Last Closed Ctrl+Shift+T Close Tab Close active tab Close Tab Ctrl+W Find and Open Graph Find and Open Graph Ctrl+P Alignment Name What's this Tool tip Shortcut Toggle Grid Snapping Toggles grid snapping while moving nodes. Toggle snap to grid Ctrl+G Display Name What's this Tool tip Shortcut Raw View Displays raw editor values for this tab. Toggle editor view Q Resolved View Displays resolved values for this tab. Toggle resolved view W Cached View Displays cached values for this tab. Toggle cached view E Graph Name What's this Tool tip Shortcut Display Node Tooltips Display Node Tooltips Frame All Frames all nodes so they are visible. Frame all nodes A Frame Selection Frames the selected node. Frame selected node F Display No Attrs Display no attributes Display No Attrs 0 Display Local Attrs Display local attributes only Display Local Attrs 1 Display Local+Inst Attrs Display local and instanced attributes Display Local+Inst Attrs 2 Display All Attrs Display local, instanced, and inherited attributes Display All Attrs 3 Toggle Grid Shows or hides the grid for all tabs. Show / Hide the Grid Ctrl+; Toggle Implicit Connections Shows or hides the implicit connections for this tab. Show / Hide Implicit Connections Ctrl+L Pick walk up Pick walk up Up Pick walk down Pick walk down Down Pick walk left Pick walk left Left Pick walk right Pick walk right Right Nudge up Nudge up Shift+Up Nudge down Nudge down Shift+Down Nudge up Nudge up Shift+Up Nudge left Nudge left Shift+Left Nudge right Nudge right Shift+Right Layers Name What's this Tool tip Shortcut Save Layer Saves the current layer to disc Save Layer Ctrl+S Save Layer As Save Layer As Ctrl+Shift+S Save All Layers Save All Layers Open Source Open target layer in new tab. Open Source Ctrl+Shift+O Toggle Layer Mute Toggle Layer Mute M Toggle Layer Solo Toggle Layer Solo S Change Color Change Color Change Alias Change Alias Create Layer Above Create Layer Above Create Layer Below Create Layer Below Reference Layer Above Reference Layer Above Reference Layer Below Reference Layer Below Remove Layer Remove Layer Layer Manager as Table Layer Manager as Table V Nodes Name What's this Tool tip Shortcut Select All Nodes Select All Nodes Ctrl+A Add Node Add a new node to the current graph Add Node N Delete Node Delete the selected node(s). Delete Node Del Recursive Delete Node Delete selected node and all of its descendants recursively. Recursive Delete Node Shift+Del Cut Cut Ctrl+X Copy Copy Ctrl+C Paste Paste Ctrl+V Duplicate Node Duplicate Node Ctrl+D Instance Node Instance Node Ctrl+I Remove Instance Removes instance path from node overloading weaker layer instance opinions. Removes Instance Ctrl+Shift+I Localize Node Localize Node Revert Node Revert Node Enable/Disable Node Enable/Disable Node D Parent Parent node(s). Parent P Un-Parent Un-parent node(s). Un-Parent Shift+P Move up in child order Move up in child order Ctrl+Up Move down in child order Move down in child order Ctrl+Down Toggle Node Collapse Toggle the collapse state for the selected node(s). Toggle Node Collapse Alt+C Recursive Toggle Node Collapse Recursively toggle the collapse state for the selected node(s). Recursive Toggle Node Collapse Alt+Shift+C Rename Node Rename Node Revert child order Revert child order Property Editor Name What's this Tool tip Shortcut Localize Instance Path Localize Instance Path Revert Instance Path Revert Instance Path Localize Exec Path Localize Exec Path Revert Exec Path Revert Exec Path Add Attribute Add Attribute Ctrl+A Remove Attribute Remove Attribute Localize Attribute Localize Attribute Revert Attribute Revert Attribute Node Comment Name What's this Tool tip Shortcut Accept Node Comment Accepts the current text in the comment box as the node comment. Accept Node Comment Ctrl+Return Cancel Node Comment Cancels the edit of the node comment. Cancel Node Comment Esc Graph Execution Name What's this Tool tip Shortcut Run Build Runs build specified by the current value of build view. Run Build Execute Graph Execute Graph Execute Selected Execute Selected Enter Execute From Selected Execute from the currently selected node and continue down the exec chain. Execute Execute Hierarchy Execute Hierarchy Add Start Point Add Start Point Remove Start Point Remove Start Point Revert Start Point Revert Start Point Find Startpoint Cycles the node focus through all start points. Find Startpoint(s) Add Breakpoint Adds the breakpoint on the selected node(s). Add Breakpoint Remove Breakpoint Removes the breakpoint on the selected node(s). Remove Breakpoint Clear All Breakpoints Clear All Breakpoints Clear Cache Clears the Python interpreter and cached data. Clear Cache Now Workflow Tools Always Recomp Workflow Tools Always Recomp Toggle Start Point Toggles a startpoint on the selected node. Toggle Start Point S Toggle Breakpoint Toggles a breakpoint on the selected node(s). Toggle Breakpoint B Stop Execution Stop Execution Esc Pause Execution Pause Execution Step Build Step Build Code Editor Name What's this Tool tip Shortcut Copy Resolved Code Copy the entire (resolved) contents of the code editor. Copy Resolved Code Ctrl+Shift+C Localize Code Localize the code to the target layer's node. Localize Code Revert Code Revert the code to the next strongest opinion. Revert Code Increase Font Size Increase the code editor font size. Increase Font Size Ctrl+= Decrease Font Size Decrease the code editor font size. Decrease Font Size Ctrl+- Revert Font Size Revert the code editor font size to default. Revert Font Size Ctrl+0 New Line Insert a new line. New Line Return Indent Line Indent selected line(s). Indent Line Tab Un-Indent Line Un-indent selected line(s). Un-Indent Line Shift+Tab Execute Selection Globally Execute selected line(s)All declared variable will be globally available. Execute Selection Globally Ctrl+Shift+Return Execute Selection Locally Execute selected line(s) Locally declared variables fall out of scope after execution. Execute Selection Locally Shift+Return Comment Line Comment the selected line(s). Comment Line Ctrl+/ Accept Code Edit Accept changes and commit them to the node. Accept Code Edit Enter Cancel Code Edit Discard changes to the code. Cancel Code Edit Esc","title":"Hotkeys"},{"location":"hotkeys/#application-actions","text":"Name What's this Tool tip Shortcut Find Node Search for, select, and focus nodes in the view Find Node / New Graph New empty graph. New Graph Ctrl+N Open Graph Open nxt file. Open Graph Ctrl+O Undo Undo last command. Undo Ctrl+Z Redo Redo last command. Redo Ctrl+Shift+Z Layer Manager Toggle the layer manager widget. Layer Manager Property Editor Toggle the property editor widget. Property Editor Code Editor Toggle the code editor widget. Code Editor History View Toggle the history view widget. History View Build View Toggle the build view widget. Build View Output Log Toggle the output log widget. Output Log Hotkey Editor Toggle the hotkey editor widget. Hotkey Editor Workflow Tools Workflow tools dock widget. Workflow Tools Exit Close nxt. Exit Alt+F4 Open Last Closed Open previously closed file(s) Open Last Closed Ctrl+Shift+T Close Tab Close active tab Close Tab Ctrl+W Find and Open Graph Find and Open Graph Ctrl+P","title":"Application Actions"},{"location":"hotkeys/#alignment","text":"Name What's this Tool tip Shortcut Toggle Grid Snapping Toggles grid snapping while moving nodes. Toggle snap to grid Ctrl+G","title":"Alignment"},{"location":"hotkeys/#display","text":"Name What's this Tool tip Shortcut Raw View Displays raw editor values for this tab. Toggle editor view Q Resolved View Displays resolved values for this tab. Toggle resolved view W Cached View Displays cached values for this tab. Toggle cached view E","title":"Display"},{"location":"hotkeys/#graph","text":"Name What's this Tool tip Shortcut Display Node Tooltips Display Node Tooltips Frame All Frames all nodes so they are visible. Frame all nodes A Frame Selection Frames the selected node. Frame selected node F Display No Attrs Display no attributes Display No Attrs 0 Display Local Attrs Display local attributes only Display Local Attrs 1 Display Local+Inst Attrs Display local and instanced attributes Display Local+Inst Attrs 2 Display All Attrs Display local, instanced, and inherited attributes Display All Attrs 3 Toggle Grid Shows or hides the grid for all tabs. Show / Hide the Grid Ctrl+; Toggle Implicit Connections Shows or hides the implicit connections for this tab. Show / Hide Implicit Connections Ctrl+L Pick walk up Pick walk up Up Pick walk down Pick walk down Down Pick walk left Pick walk left Left Pick walk right Pick walk right Right Nudge up Nudge up Shift+Up Nudge down Nudge down Shift+Down Nudge up Nudge up Shift+Up Nudge left Nudge left Shift+Left Nudge right Nudge right Shift+Right","title":"Graph"},{"location":"hotkeys/#layers","text":"Name What's this Tool tip Shortcut Save Layer Saves the current layer to disc Save Layer Ctrl+S Save Layer As Save Layer As Ctrl+Shift+S Save All Layers Save All Layers Open Source Open target layer in new tab. Open Source Ctrl+Shift+O Toggle Layer Mute Toggle Layer Mute M Toggle Layer Solo Toggle Layer Solo S Change Color Change Color Change Alias Change Alias Create Layer Above Create Layer Above Create Layer Below Create Layer Below Reference Layer Above Reference Layer Above Reference Layer Below Reference Layer Below Remove Layer Remove Layer Layer Manager as Table Layer Manager as Table V","title":"Layers"},{"location":"hotkeys/#nodes","text":"Name What's this Tool tip Shortcut Select All Nodes Select All Nodes Ctrl+A Add Node Add a new node to the current graph Add Node N Delete Node Delete the selected node(s). Delete Node Del Recursive Delete Node Delete selected node and all of its descendants recursively. Recursive Delete Node Shift+Del Cut Cut Ctrl+X Copy Copy Ctrl+C Paste Paste Ctrl+V Duplicate Node Duplicate Node Ctrl+D Instance Node Instance Node Ctrl+I Remove Instance Removes instance path from node overloading weaker layer instance opinions. Removes Instance Ctrl+Shift+I Localize Node Localize Node Revert Node Revert Node Enable/Disable Node Enable/Disable Node D Parent Parent node(s). Parent P Un-Parent Un-parent node(s). Un-Parent Shift+P Move up in child order Move up in child order Ctrl+Up Move down in child order Move down in child order Ctrl+Down Toggle Node Collapse Toggle the collapse state for the selected node(s). Toggle Node Collapse Alt+C Recursive Toggle Node Collapse Recursively toggle the collapse state for the selected node(s). Recursive Toggle Node Collapse Alt+Shift+C Rename Node Rename Node Revert child order Revert child order","title":"Nodes"},{"location":"hotkeys/#property-editor","text":"Name What's this Tool tip Shortcut Localize Instance Path Localize Instance Path Revert Instance Path Revert Instance Path Localize Exec Path Localize Exec Path Revert Exec Path Revert Exec Path Add Attribute Add Attribute Ctrl+A Remove Attribute Remove Attribute Localize Attribute Localize Attribute Revert Attribute Revert Attribute","title":"Property Editor"},{"location":"hotkeys/#node-comment","text":"Name What's this Tool tip Shortcut Accept Node Comment Accepts the current text in the comment box as the node comment. Accept Node Comment Ctrl+Return Cancel Node Comment Cancels the edit of the node comment. Cancel Node Comment Esc","title":"Node Comment"},{"location":"hotkeys/#graph-execution","text":"Name What's this Tool tip Shortcut Run Build Runs build specified by the current value of build view. Run Build Execute Graph Execute Graph Execute Selected Execute Selected Enter Execute From Selected Execute from the currently selected node and continue down the exec chain. Execute Execute Hierarchy Execute Hierarchy Add Start Point Add Start Point Remove Start Point Remove Start Point Revert Start Point Revert Start Point Find Startpoint Cycles the node focus through all start points. Find Startpoint(s) Add Breakpoint Adds the breakpoint on the selected node(s). Add Breakpoint Remove Breakpoint Removes the breakpoint on the selected node(s). Remove Breakpoint Clear All Breakpoints Clear All Breakpoints Clear Cache Clears the Python interpreter and cached data. Clear Cache Now Workflow Tools Always Recomp Workflow Tools Always Recomp Toggle Start Point Toggles a startpoint on the selected node. Toggle Start Point S Toggle Breakpoint Toggles a breakpoint on the selected node(s). Toggle Breakpoint B Stop Execution Stop Execution Esc Pause Execution Pause Execution Step Build Step Build","title":"Graph Execution"},{"location":"hotkeys/#code-editor","text":"Name What's this Tool tip Shortcut Copy Resolved Code Copy the entire (resolved) contents of the code editor. Copy Resolved Code Ctrl+Shift+C Localize Code Localize the code to the target layer's node. Localize Code Revert Code Revert the code to the next strongest opinion. Revert Code Increase Font Size Increase the code editor font size. Increase Font Size Ctrl+= Decrease Font Size Decrease the code editor font size. Decrease Font Size Ctrl+- Revert Font Size Revert the code editor font size to default. Revert Font Size Ctrl+0 New Line Insert a new line. New Line Return Indent Line Indent selected line(s). Indent Line Tab Un-Indent Line Un-indent selected line(s). Un-Indent Line Shift+Tab Execute Selection Globally Execute selected line(s)All declared variable will be globally available. Execute Selection Globally Ctrl+Shift+Return Execute Selection Locally Execute selected line(s) Locally declared variables fall out of scope after execution. Execute Selection Locally Shift+Return Comment Line Comment the selected line(s). Comment Line Ctrl+/ Accept Code Edit Accept changes and commit them to the node. Accept Code Edit Enter Cancel Code Edit Discard changes to the code. Cancel Code Edit Esc","title":"Code Editor"},{"location":"install/","text":"Standalone Installation Linux, Mac, Windows If you're trying to install on Windows in a Python 2 environment see here To install the latest release directly from PyPi follow the following steps. Note The nxt-core is just the Python backend of NXT, it does not include the visual editor. The core will automatically install with the nxt-editor . Video Written First time install For just the cli and backend: pip install nxt-core For the backend and the visual editor: pip install nxt-editor Launch (nxt editor) nxt ui Update pip install -U nxt-core pip install -U nxt-editor To execute a graph with the nxt Python core, use the following: import nxt nxt.execute_graph('path/to/graph.nxt') Windows (Python 2.7) If you're installing into a Python 3.7.x environment you can use the above steps Note These steps are only necessary if you want to use the nxt standalone editor outside of Maya. The nxt-core will pip install on Windows Python 2.7 without issue. Due to the limited availability of PySide2 on Windows for Python 2.7 the steps to install on Windows are slightly more involved. For the simplest instructions, please follow the developer installation steps . If you're comfortable working in an IDE and using git we suggest you follow the contributing documentation . Maya plugin Our Maya plugin comes with both a visual editor and the core. We've tested Maya 2018-20 on all platforms. Video Written Install: Download the maya module( nxt_maya.zip ) from the latest release Follow the nxt_maya README instructions (also included in the download) Launch: Load nxt_maya plugin in Maya Select the nxt menu from the menus at the top of Maya Click Open Editor Update: Download the nxt_maya zip from the latest release Extract the zip and replace the existing nxt_maya files with the newly extracted files. Re-launch Maya Planned plugins: Houdini Nuke Blender Developer Installation See our contributing documentation NXT Python Dev Environment (Miniconda) The following steps are only needed if you intend on contributing to the NXT codebase or you are trying to install NXT standalone on Windows Python 2.7. To get the correct Python environment setup on your Windows machine you will need to follow these steps. The nxt environment is specified in our nxt_env.yml . Conda is best installed via miniconda . We recommend not adding conda python to your system path and not making it your system python. You can either clone the nxt source from our core repo / editor repo or download the desired core release / editor release source code zip and extract it. Lets assume you place the source code at C:/Projects/nxt Launch the Anaconda Prompt and install dependencies: conda env create -f C:/Projects/nxt/nxt_env.yml Launching the nxt editor From Anaconda Prompt conda activate nxt cd C:/Projects/nxt python -m nxt.cli ui From Python import nxt_editor GRAPHS_TO_OPEN = ['a_graph.nxt'] or None nxt_editor.launch_editor(paths=GRAPHS_TO_OPEN, start_rpc=True) Bootstrapping nxt Tested with Maya2018/19/20, Houdini18, Nuke11,12 Warning This setup is temporary, and will eventually be replaced with a command port connections with host plugins. Find your conda env with this command in the Anaconda Prompt: conda info --envs Copy the following code into Maya and edit NXT_PATH and ENV_PATH to reflect your environment. You can then drag it to your shelf or save it to a file, up to you. import sys import os # path to your nxt clone NXT_PATH = '~/Projects/Sun/nxt' # path to conda env ENV_PATH = 'C:/ProgramData/Miniconda2/envs/nxt/Lib/site-packages' # Default file(s) to open, can be `None` LAUNCH_FILES = ['~/Projects/SomeGraph.nxt'] if ENV_PATH not in sys.path: sys.path.append(os.path.expanduser(ENV_PATH)) if NXT_PATH not in sys.path: sys.path.append(os.path.expanduser(NXT_PATH)) from Qt import QtCore import nxt_editor # The `paths` kwarg can be omited if you don't want to open any graphs. # Due to the way some thrid party Python interpeters are setup, we recommened setting `start_rpc` to `False`. instance = nxt_editor.show_new_editor(paths=LAUNCH_FILES, start_rpc=False) if sys.platform == 'win32': instance.setWindowFlags(QtCore.Qt.Window) # To force close the instance run this line: # instance.close() Optional window attach To attach to the main window in Nuke def _nuke_main_window(): \"\"\"Returns Nuke's main window\"\"\" for obj in QtWidgets.QApplication.topLevelWidgets(): if (obj.inherits('QMainWindow') and obj.metaObject().className() == 'Foundry::UI::DockMainWindow'): return obj else: raise RuntimeError('Could not find DockMainWindow instance') nuke_window = _nuke_main_window() instance = nxt_editor.show_new_editor(start_rpc=False) instance.setParent(nuke_window, QtCore.Qt.Window) To Attach to the main window in Houdini from hutil.Qt import QtCore instance = nxt_editor.show_new_editor(start_rpc=False) instance.setParent(hou.qt.mainWindow(), QtCore.Qt.Window) To Attach to the main window in Maya import maya.OpenMayaUI as mui pointer = mui.MQtUtil.mainWindow() maya_window = QtCompat.wrapInstance(long(pointer), QtWidgets.QWidget) instance = nxt_editor.show_new_editor(start_rpc=False) instance.setParent(hou.qt.mainWindow(), QtCore.Qt.Window)","title":"Installation"},{"location":"install/#linux-mac-windows","text":"If you're trying to install on Windows in a Python 2 environment see here To install the latest release directly from PyPi follow the following steps. Note The nxt-core is just the Python backend of NXT, it does not include the visual editor. The core will automatically install with the nxt-editor .","title":"Linux, Mac, Windows"},{"location":"install/#video","text":"","title":"Video"},{"location":"install/#written","text":"First time install For just the cli and backend: pip install nxt-core For the backend and the visual editor: pip install nxt-editor Launch (nxt editor) nxt ui Update pip install -U nxt-core pip install -U nxt-editor To execute a graph with the nxt Python core, use the following: import nxt nxt.execute_graph('path/to/graph.nxt')","title":"Written"},{"location":"install/#windows-python-27","text":"If you're installing into a Python 3.7.x environment you can use the above steps Note These steps are only necessary if you want to use the nxt standalone editor outside of Maya. The nxt-core will pip install on Windows Python 2.7 without issue. Due to the limited availability of PySide2 on Windows for Python 2.7 the steps to install on Windows are slightly more involved. For the simplest instructions, please follow the developer installation steps . If you're comfortable working in an IDE and using git we suggest you follow the contributing documentation .","title":"Windows (Python 2.7)"},{"location":"install/#maya-plugin","text":"Our Maya plugin comes with both a visual editor and the core. We've tested Maya 2018-20 on all platforms.","title":"Maya plugin"},{"location":"install/#video_1","text":"","title":"Video"},{"location":"install/#written_1","text":"Install: Download the maya module( nxt_maya.zip ) from the latest release Follow the nxt_maya README instructions (also included in the download) Launch: Load nxt_maya plugin in Maya Select the nxt menu from the menus at the top of Maya Click Open Editor Update: Download the nxt_maya zip from the latest release Extract the zip and replace the existing nxt_maya files with the newly extracted files. Re-launch Maya","title":"Written"},{"location":"install/#planned-plugins","text":"Houdini Nuke Blender","title":"Planned plugins:"},{"location":"install/#developer-installation","text":"See our contributing documentation","title":"Developer Installation"},{"location":"install/#nxt-python-dev-environment-miniconda","text":"The following steps are only needed if you intend on contributing to the NXT codebase or you are trying to install NXT standalone on Windows Python 2.7. To get the correct Python environment setup on your Windows machine you will need to follow these steps. The nxt environment is specified in our nxt_env.yml . Conda is best installed via miniconda . We recommend not adding conda python to your system path and not making it your system python. You can either clone the nxt source from our core repo / editor repo or download the desired core release / editor release source code zip and extract it. Lets assume you place the source code at C:/Projects/nxt Launch the Anaconda Prompt and install dependencies: conda env create -f C:/Projects/nxt/nxt_env.yml","title":"NXT Python Dev Environment (Miniconda)"},{"location":"install/#launching-the-nxt-editor","text":"From Anaconda Prompt conda activate nxt cd C:/Projects/nxt python -m nxt.cli ui From Python import nxt_editor GRAPHS_TO_OPEN = ['a_graph.nxt'] or None nxt_editor.launch_editor(paths=GRAPHS_TO_OPEN, start_rpc=True)","title":"Launching the nxt editor"},{"location":"install/#bootstrapping-nxt","text":"Tested with Maya2018/19/20, Houdini18, Nuke11,12 Warning This setup is temporary, and will eventually be replaced with a command port connections with host plugins. Find your conda env with this command in the Anaconda Prompt: conda info --envs Copy the following code into Maya and edit NXT_PATH and ENV_PATH to reflect your environment. You can then drag it to your shelf or save it to a file, up to you. import sys import os # path to your nxt clone NXT_PATH = '~/Projects/Sun/nxt' # path to conda env ENV_PATH = 'C:/ProgramData/Miniconda2/envs/nxt/Lib/site-packages' # Default file(s) to open, can be `None` LAUNCH_FILES = ['~/Projects/SomeGraph.nxt'] if ENV_PATH not in sys.path: sys.path.append(os.path.expanduser(ENV_PATH)) if NXT_PATH not in sys.path: sys.path.append(os.path.expanduser(NXT_PATH)) from Qt import QtCore import nxt_editor # The `paths` kwarg can be omited if you don't want to open any graphs. # Due to the way some thrid party Python interpeters are setup, we recommened setting `start_rpc` to `False`. instance = nxt_editor.show_new_editor(paths=LAUNCH_FILES, start_rpc=False) if sys.platform == 'win32': instance.setWindowFlags(QtCore.Qt.Window) # To force close the instance run this line: # instance.close()","title":"Bootstrapping nxt"},{"location":"install/#optional-window-attach","text":"To attach to the main window in Nuke def _nuke_main_window(): \"\"\"Returns Nuke's main window\"\"\" for obj in QtWidgets.QApplication.topLevelWidgets(): if (obj.inherits('QMainWindow') and obj.metaObject().className() == 'Foundry::UI::DockMainWindow'): return obj else: raise RuntimeError('Could not find DockMainWindow instance') nuke_window = _nuke_main_window() instance = nxt_editor.show_new_editor(start_rpc=False) instance.setParent(nuke_window, QtCore.Qt.Window) To Attach to the main window in Houdini from hutil.Qt import QtCore instance = nxt_editor.show_new_editor(start_rpc=False) instance.setParent(hou.qt.mainWindow(), QtCore.Qt.Window) To Attach to the main window in Maya import maya.OpenMayaUI as mui pointer = mui.MQtUtil.mainWindow() maya_window = QtCompat.wrapInstance(long(pointer), QtWidgets.QWidget) instance = nxt_editor.show_new_editor(start_rpc=False) instance.setParent(hou.qt.mainWindow(), QtCore.Qt.Window)","title":"Optional window attach"},{"location":"license/","text":"NXT License The MIT License (MIT) Copyright (c) 2018-2020 The NXT Authors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Feathericons License The MIT License (MIT) Copyright (c) 2013-2017 Cole Bemis Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#nxt-license","text":"The MIT License (MIT) Copyright (c) 2018-2020 The NXT Authors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"NXT License"},{"location":"license/#feathericons-license","text":"The MIT License (MIT) Copyright (c) 2013-2017 Cole Bemis Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Feathericons License"},{"location":"reference/","text":"Example Graphs Checkout our example graphs here . If you're looking for workflow checkout our workflow and transition map here . Editors Stage View Node Properties Code Editor Layer manager Tool Bar Output Log Build View History View Hotkey Editor Terms and Definitions Stage The stage is a collection of graphs, trees, and layers of nxt nodes that set the composition structure and execution order for an nxt file. Every node has access to the STAGE object. When working with Python classes (besides the builtins) it is best to store those objects on the STAGE . An example of how you would do that in a node's code is as follows: my_object = ComplexData() STAGE.complex_data = my_object Another node later in the execution can access that object as follows: STAGE.complex_data.a_method() Stage attributes and composition Note that each layer is also a node, and those nodes get composited to the STAGE object. Each node is parented to that object and inherit the attributes of it. This can be useful for defining \"global\" variables, or a state that needs to propagate into the entire graph. Node A node is a container for code (or compute) and a collection of attributes. Every node contains a single code block that is executed when a node is run. Execution order is defined both by hierarchy and connections to execution plugs on the nodes. Attributes Nodes contain attributes that are read from and written to from inside a node\u2019s code block . Attributes can also be connected to inputs and outputs of other nodes via tokens in attributes, token paths within the code block, or dragging and dropping attribute connections between nodes. At editor time (before the graph has begun executing ) attribute values can be composited into other attribute\u2019s values or into the text of a code block via ${path/to/node.otherattr}_rest_of_attr_value . A node\u2019s local attributes can be resolved by name alone via ${attrname} Hotkeys The raw/composited state can be visualized by toggling editor resolution on and off using Q , W , E . NXT includes a full hot key editor. (Window > Hotkey Editor) Example The node at /path/to/node has the attribute otherattr with the value simple_stupid , and our local node has an attribute named myattr with the value never_eat Unresolved Resolved keep_it_${path/to/node.attrname} keep_it_simple_stupid ${myattr}_shredded_wheat never_eat_shredded_wheat Cached view Cached view should only be used to inspect and debug your data. It should not be considered accurate, especially if you are changing the data via the self.attribute paridigm. Any data that NXT is not confident in will be drawn with red hashes. A node\u2019s local attributes can be changed inside a node\u2019s code block following python convention as seen below. self.attr_name = 'example code' print(self.attr_name + ' is always boring.') While executing, the Stage can have arbitrary attributes add/set/retrieved on it, that will be available to all nodes, as seen below. Note: Inside a node\u2019s codeblock the stage is accessed via all caps STAGE STAGE.anyattr = 'anything you want' print(Stage.anyattr) Attribute connections It is best practice to display inter-node dependencies via hierarchy or connections of attributes, rather than hide that dependency in the code. This will make your layers more portable and friendly to other users. Despite this best practice, other nodes and their attributes can be accessed inside a code block using STAGE.lookup('path/to/node') and STAGE.lookup('path/to/node.otherattr') . Tokens A token is like a reference or pointer to another token or value. OS style pathing is used to resolve attribute and file tokens. Attribute token syntax is ${} : if it can resolve, it substitutes the attribute, if not it will be empty. If a token is empty it will resolve to BADRESOLVE . ${attribute} ${/absolute_node_path.attribute} ${../relative_nodepath.attribute} File validation syntax ${file::} : this will always resolve to a real file, and will return an empty string if the file doesn't exist. Used to validate files for reading. ${file::file.nxt} ${file::C:/absolute_path/file.nxt} ${file::../relative_path/file.nxt} File path token syntax ${path::} this will attempt to resolve to a valid path. If not, it will be empty. Used to expand paths for writing. File path token syntax ${contents::} will include the contents of an external file. For example, ${contents::${file::external.py}} will include the contents of external.py in the attribute, compute, and it will resolve tokens written within this file. File list token syntax ${fileslist::} will list valid historical filepaths at the same path. Imagine you have /node.my_file = ${file::weights.json} on several layers in different directories, all saved in different folders. If you then used a token like ${filelist::/node.weiths_file} you would get a list of file paths to the weights.json file in each of the layer's save folder. This would allow you to collete and parse data from multiple reference layers: all_the_data = {} for filepath in ${filelist::/node.weiths_file}: all_the_data.update(json.load(filepath)) File list validation The filelist:: token only returns valid filepaths to existing files. Relative file resolution The ${file::} and ${path::} tokens will resolve relative paths based on the parent folder of the current display layer. Using an external IDE The ${contents::} token allows the use of an external IDE for authoring your compute blocks. Tokens are not python template strings, even though they share the syntax. Quote behavior in tokens Since all attribute values are stored and processed as strings in NXT before they are composed as python objects, you have to manually manage string attributes. The value will substitute as written . In some cases, it makes sense to have string attributes in quotes, in other cases, it makes sense to add quotes in the code block. For example if you had an attribute side set to a value of L foot_${side} and 'foot_' + '${side}' are equally valid. This really comes down to convention. There is a simple w() convenience function to assist with adding quotes when using a python string object as a string. my_attr = 'quotes go away when it becomes a string object' self.attribute = w(my_attr) my_attr can now be used by downstream nodes as a string. Compute The compute block/code block is standard python code, with the exception that it will deep-resolve tokens over 1000 levels deep. (should this be a preference?) Hotkeys The raw/composited state can be visualized by toggling editor resolution on and off using Q , W , E . numreturn or ctrl+enter or clicking off the code will accept your edit tab and shift+tab handle multi-line indents NXT includes a full hot key editor.(Window > Hotkey Editor) Execution Order Stage/Layer Node Stub for this feature once new layer editor arrives Execution Root A stage can have root nodes with no parent node and no node connected to it\u2019s input execution plug. Use execute tags to define the order Execution Plugs Nodes have execution plugs on their left and right to determine execution order. Nodes are executed from left to right along the execution chain specified by these connections. Danger We don't have checks for circular dependencies yet. So don't setup loops. Hierarchies/Stacks Nodes have relationships we refer to as \u201cparent\u201d, \u201cchild\u201d, and \u201csibling\u201d to describe their relationship to one another inside the stage to influence composition and execution order. To begin execution from a given node, the first node is run, followed by a depth first execution of each of it\u2019s descendants. Following the execution of the descendants, the root node whose input execution plug is connected to the current node\u2019s output execution plug will be run following the same logic. Stage Composition Layers Layers are designed to be composited (combined) to create a hierarchy of instructions that can be reused and repurposed by several NXT users for use on several assets or workflows. Multiple layers can be referenced and nxt seamlessly combines them into a single composite layer. All of the layers in your file are composited together to produce final code to execute. Each layer has the power to change as much or as little as is needed to customize the composited node\u2019s attributes and code block. These changes are stored in the file they are made on, keeping referenced files safe to use for many purposes. Layer color propagates into nodes an also attributes. Composition Inside Node Hierarchies When a node is a child of another node, it inherits its attributes from that node which can be overwritten locally on the node. Instancing Instancing allows you to reuse nodes from other parts of the graph with specific overrides. Instances in NXT can be simple and powerful. But they can also be extremely complicated with mind-bending edge cases. In simple terms, you can think about an instance as a clone of another node. It's like a live copy. But it's a bit more nuanced to think about an instance like an additional parent that's outside the hierarchy. Example If you create a node, don't add any attributes or code, it will just look like a clone of the instance source. If you create a node with unique attributes it will look like the instance source is another parent. All the attributes will composite from the instance source, and the local attributes will be visible as well. - If you create a node with attributes named the same as the instance source, the local attributes will have a stronger opinion and overwrite the instance values. In this case, cat exists on custom_node so it's value wins. The children of the instance node get inserted into the hierarchy as proxy children. This data exists only as a result of the composite. The are not local saved data. Proxy children are drawn in a hashed style to make it clear you haven't touched the data. As soon as you begin to edit proxy children, they are converted into real editable nodes and exist in the hierarchy. Note The hierarchy has the final opinion in the composite. UNLESS the node has an local opinion on the data. Layer Node parent Node Instance parent Instance Example Build a base arm. Instance it twice. Change L to R, done. An instance of a node inherits data like a child. It creates proxy children of the instance source\u2019s children, and can be arranged into a separate parent-child relationship as it\u2019s instance source. Most instance attributes are carried over. Execution input is never inherited. Child order is inherited by instances but not by children. Data comes from the hierarchical parent as well as the instance source, with hierarchical parent having final word. Instance execution order is defined by the hierarchical parent. Danger If a node instances itself, or any ancestor or descendants, it will crash. It's best (because that's all thats possible) to only instance from other hierarchies or sibling nodes NXT file spec NXT files follow standard .json file specifications with a few specific keys in the root dictionary. Required: version - str, graph version number Optional: alias - str, nice name for layer. color - str, hex color. mute - bool, mute layer when loaded as top layer. solo - bool, solo layer when loaded as top layer. references - list, string file paths to reference layers, ordered top to bottom (strong to weak). File paths can be relative. meta_data - dict, data about the graph not affecting its execution or composition. nodes - dict, key of /full/node/path and value of a node dict . Node Dict The node dict is what holds all the local opinions (values) about a node. All the keys are optional, however we recommend having at least 1 key and value, otherwise it is best to just delete the node. child_order - list, strings of children node names in the order they should be executed. comment - string, think of this like a node's docstring. code - list, string lines of code that the node will run when it is executed. enabled - bool, if false the node will not execute. Should be omitted from the dict unless explicitly needed as nodes with no key are assumed enabled. execute_in - str, path to root node whose hierarchy executes directly before this node's hierarchy. Only applicable on root nodes. instance - str, full or partial node path of node this node should derive its instance data from. This path should not be an ancestor, descendant, of this node nor the path of this node. start_point - bool, if true the node will be treated as a start node. Only applicable on root nodes. Design Philosophy Nobody will ever read this pretentious wall of text, but it was an important part of the development process. We hope you find it interesting, and you may find your way here if your start to dig deeper and wonder why things are the way they are. Discovery Nxt provides a visual map/model of user facing attributes that can be understood at a glance, and presents the code in context. This invites the user to extend and modify the functionality. Nxt is designed around making processes and code as accessible as possible with low overhead. Artists can modify attributes on code templates and learn to make code changes that would normally require a TD. TD\u2019s can establish layered templates for processes and write nodes and graphs. Developers can provide Nxt \u2018factory nodes\u2019 for using their tools without writing a custom UI. Functional/Procedural Nxt follows a functional model. It eschews object oriented inheritance with a layer model. This allows data to be inspected on the fly and easily read. Why not visual programming? Nxt differs from a visual programming environment where every function (math, concatenation, data, flow control) is wrapped up in a node. Fully visual programming environments result in sprawling graphs. While the functions are readable, they are not dense. Nxt displays code standard text notation but creates a visualization for the data. VP graphs can be tedious to construct. A simple operation can often require a dozen nodes but could be represented in 3 lines of code. VP graphs are code under the surface anyway, so to extend the functionality, you need to write code, or construct graphs of graphs. VP is a great tool for visualization of your data and flow, readability, experimentation, and discovery. NXT is half visual. Half code. Seeks to keep the best parts and remove the friction for more seasoned developers. Why not Houdini? Houdini is a tool for building tools. It\u2019s a visual processing engine. Can\u2019t it do all of this already? Houdini doesn\u2019t do layering Houdini is great, but maybe not the best at everything Artists have decades of experience in other tools Large segments of production already built around need to be built around Maya, Nuke, Unreal HDA\u2019s are black boxes and can be slow in host applications PDG is great, and expensive. Application structure","title":"Reference"},{"location":"reference/#example-graphs","text":"Checkout our example graphs here . If you're looking for workflow checkout our workflow and transition map here .","title":"Example Graphs"},{"location":"reference/#editors","text":"Stage View Node Properties Code Editor Layer manager Tool Bar Output Log Build View History View Hotkey Editor","title":"Editors"},{"location":"reference/#terms-and-definitions","text":"","title":"Terms and Definitions"},{"location":"reference/#stage","text":"The stage is a collection of graphs, trees, and layers of nxt nodes that set the composition structure and execution order for an nxt file. Every node has access to the STAGE object. When working with Python classes (besides the builtins) it is best to store those objects on the STAGE . An example of how you would do that in a node's code is as follows: my_object = ComplexData() STAGE.complex_data = my_object Another node later in the execution can access that object as follows: STAGE.complex_data.a_method() Stage attributes and composition Note that each layer is also a node, and those nodes get composited to the STAGE object. Each node is parented to that object and inherit the attributes of it. This can be useful for defining \"global\" variables, or a state that needs to propagate into the entire graph.","title":"Stage"},{"location":"reference/#node","text":"A node is a container for code (or compute) and a collection of attributes. Every node contains a single code block that is executed when a node is run. Execution order is defined both by hierarchy and connections to execution plugs on the nodes.","title":"Node"},{"location":"reference/#attributes","text":"Nodes contain attributes that are read from and written to from inside a node\u2019s code block . Attributes can also be connected to inputs and outputs of other nodes via tokens in attributes, token paths within the code block, or dragging and dropping attribute connections between nodes. At editor time (before the graph has begun executing ) attribute values can be composited into other attribute\u2019s values or into the text of a code block via ${path/to/node.otherattr}_rest_of_attr_value . A node\u2019s local attributes can be resolved by name alone via ${attrname} Hotkeys The raw/composited state can be visualized by toggling editor resolution on and off using Q , W , E . NXT includes a full hot key editor. (Window > Hotkey Editor) Example The node at /path/to/node has the attribute otherattr with the value simple_stupid , and our local node has an attribute named myattr with the value never_eat Unresolved Resolved keep_it_${path/to/node.attrname} keep_it_simple_stupid ${myattr}_shredded_wheat never_eat_shredded_wheat Cached view Cached view should only be used to inspect and debug your data. It should not be considered accurate, especially if you are changing the data via the self.attribute paridigm. Any data that NXT is not confident in will be drawn with red hashes. A node\u2019s local attributes can be changed inside a node\u2019s code block following python convention as seen below. self.attr_name = 'example code' print(self.attr_name + ' is always boring.') While executing, the Stage can have arbitrary attributes add/set/retrieved on it, that will be available to all nodes, as seen below. Note: Inside a node\u2019s codeblock the stage is accessed via all caps STAGE STAGE.anyattr = 'anything you want' print(Stage.anyattr) Attribute connections It is best practice to display inter-node dependencies via hierarchy or connections of attributes, rather than hide that dependency in the code. This will make your layers more portable and friendly to other users. Despite this best practice, other nodes and their attributes can be accessed inside a code block using STAGE.lookup('path/to/node') and STAGE.lookup('path/to/node.otherattr') .","title":"Attributes"},{"location":"reference/#tokens","text":"A token is like a reference or pointer to another token or value. OS style pathing is used to resolve attribute and file tokens. Attribute token syntax is ${} : if it can resolve, it substitutes the attribute, if not it will be empty. If a token is empty it will resolve to BADRESOLVE . ${attribute} ${/absolute_node_path.attribute} ${../relative_nodepath.attribute} File validation syntax ${file::} : this will always resolve to a real file, and will return an empty string if the file doesn't exist. Used to validate files for reading. ${file::file.nxt} ${file::C:/absolute_path/file.nxt} ${file::../relative_path/file.nxt} File path token syntax ${path::} this will attempt to resolve to a valid path. If not, it will be empty. Used to expand paths for writing. File path token syntax ${contents::} will include the contents of an external file. For example, ${contents::${file::external.py}} will include the contents of external.py in the attribute, compute, and it will resolve tokens written within this file. File list token syntax ${fileslist::} will list valid historical filepaths at the same path. Imagine you have /node.my_file = ${file::weights.json} on several layers in different directories, all saved in different folders. If you then used a token like ${filelist::/node.weiths_file} you would get a list of file paths to the weights.json file in each of the layer's save folder. This would allow you to collete and parse data from multiple reference layers: all_the_data = {} for filepath in ${filelist::/node.weiths_file}: all_the_data.update(json.load(filepath)) File list validation The filelist:: token only returns valid filepaths to existing files. Relative file resolution The ${file::} and ${path::} tokens will resolve relative paths based on the parent folder of the current display layer. Using an external IDE The ${contents::} token allows the use of an external IDE for authoring your compute blocks. Tokens are not python template strings, even though they share the syntax. Quote behavior in tokens Since all attribute values are stored and processed as strings in NXT before they are composed as python objects, you have to manually manage string attributes. The value will substitute as written . In some cases, it makes sense to have string attributes in quotes, in other cases, it makes sense to add quotes in the code block. For example if you had an attribute side set to a value of L foot_${side} and 'foot_' + '${side}' are equally valid. This really comes down to convention. There is a simple w() convenience function to assist with adding quotes when using a python string object as a string. my_attr = 'quotes go away when it becomes a string object' self.attribute = w(my_attr) my_attr can now be used by downstream nodes as a string.","title":"Tokens"},{"location":"reference/#compute","text":"The compute block/code block is standard python code, with the exception that it will deep-resolve tokens over 1000 levels deep. (should this be a preference?) Hotkeys The raw/composited state can be visualized by toggling editor resolution on and off using Q , W , E . numreturn or ctrl+enter or clicking off the code will accept your edit tab and shift+tab handle multi-line indents NXT includes a full hot key editor.(Window > Hotkey Editor)","title":"Compute"},{"location":"reference/#execution-order","text":"","title":"Execution Order"},{"location":"reference/#stagelayer-node","text":"Stub for this feature once new layer editor arrives","title":"Stage/Layer Node"},{"location":"reference/#execution-root","text":"A stage can have root nodes with no parent node and no node connected to it\u2019s input execution plug. Use execute tags to define the order","title":"Execution Root"},{"location":"reference/#execution-plugs","text":"Nodes have execution plugs on their left and right to determine execution order. Nodes are executed from left to right along the execution chain specified by these connections. Danger We don't have checks for circular dependencies yet. So don't setup loops.","title":"Execution Plugs"},{"location":"reference/#hierarchiesstacks","text":"Nodes have relationships we refer to as \u201cparent\u201d, \u201cchild\u201d, and \u201csibling\u201d to describe their relationship to one another inside the stage to influence composition and execution order. To begin execution from a given node, the first node is run, followed by a depth first execution of each of it\u2019s descendants. Following the execution of the descendants, the root node whose input execution plug is connected to the current node\u2019s output execution plug will be run following the same logic.","title":"Hierarchies/Stacks"},{"location":"reference/#stage-composition","text":"","title":"Stage Composition"},{"location":"reference/#layers","text":"Layers are designed to be composited (combined) to create a hierarchy of instructions that can be reused and repurposed by several NXT users for use on several assets or workflows. Multiple layers can be referenced and nxt seamlessly combines them into a single composite layer. All of the layers in your file are composited together to produce final code to execute. Each layer has the power to change as much or as little as is needed to customize the composited node\u2019s attributes and code block. These changes are stored in the file they are made on, keeping referenced files safe to use for many purposes. Layer color propagates into nodes an also attributes.","title":"Layers"},{"location":"reference/#composition-inside-node-hierarchies","text":"When a node is a child of another node, it inherits its attributes from that node which can be overwritten locally on the node.","title":"Composition Inside Node Hierarchies"},{"location":"reference/#instancing","text":"Instancing allows you to reuse nodes from other parts of the graph with specific overrides. Instances in NXT can be simple and powerful. But they can also be extremely complicated with mind-bending edge cases. In simple terms, you can think about an instance as a clone of another node. It's like a live copy. But it's a bit more nuanced to think about an instance like an additional parent that's outside the hierarchy. Example If you create a node, don't add any attributes or code, it will just look like a clone of the instance source. If you create a node with unique attributes it will look like the instance source is another parent. All the attributes will composite from the instance source, and the local attributes will be visible as well. - If you create a node with attributes named the same as the instance source, the local attributes will have a stronger opinion and overwrite the instance values. In this case, cat exists on custom_node so it's value wins. The children of the instance node get inserted into the hierarchy as proxy children. This data exists only as a result of the composite. The are not local saved data. Proxy children are drawn in a hashed style to make it clear you haven't touched the data. As soon as you begin to edit proxy children, they are converted into real editable nodes and exist in the hierarchy. Note The hierarchy has the final opinion in the composite. UNLESS the node has an local opinion on the data. Layer Node parent Node Instance parent Instance Example Build a base arm. Instance it twice. Change L to R, done. An instance of a node inherits data like a child. It creates proxy children of the instance source\u2019s children, and can be arranged into a separate parent-child relationship as it\u2019s instance source. Most instance attributes are carried over. Execution input is never inherited. Child order is inherited by instances but not by children. Data comes from the hierarchical parent as well as the instance source, with hierarchical parent having final word. Instance execution order is defined by the hierarchical parent. Danger If a node instances itself, or any ancestor or descendants, it will crash. It's best (because that's all thats possible) to only instance from other hierarchies or sibling nodes","title":"Instancing"},{"location":"reference/#nxt-file-spec","text":"NXT files follow standard .json file specifications with a few specific keys in the root dictionary. Required: version - str, graph version number Optional: alias - str, nice name for layer. color - str, hex color. mute - bool, mute layer when loaded as top layer. solo - bool, solo layer when loaded as top layer. references - list, string file paths to reference layers, ordered top to bottom (strong to weak). File paths can be relative. meta_data - dict, data about the graph not affecting its execution or composition. nodes - dict, key of /full/node/path and value of a node dict .","title":"NXT file spec"},{"location":"reference/#node-dict","text":"The node dict is what holds all the local opinions (values) about a node. All the keys are optional, however we recommend having at least 1 key and value, otherwise it is best to just delete the node. child_order - list, strings of children node names in the order they should be executed. comment - string, think of this like a node's docstring. code - list, string lines of code that the node will run when it is executed. enabled - bool, if false the node will not execute. Should be omitted from the dict unless explicitly needed as nodes with no key are assumed enabled. execute_in - str, path to root node whose hierarchy executes directly before this node's hierarchy. Only applicable on root nodes. instance - str, full or partial node path of node this node should derive its instance data from. This path should not be an ancestor, descendant, of this node nor the path of this node. start_point - bool, if true the node will be treated as a start node. Only applicable on root nodes.","title":"Node Dict"},{"location":"reference/#design-philosophy","text":"Nobody will ever read this pretentious wall of text, but it was an important part of the development process. We hope you find it interesting, and you may find your way here if your start to dig deeper and wonder why things are the way they are.","title":"Design Philosophy"},{"location":"reference/#discovery","text":"Nxt provides a visual map/model of user facing attributes that can be understood at a glance, and presents the code in context. This invites the user to extend and modify the functionality. Nxt is designed around making processes and code as accessible as possible with low overhead. Artists can modify attributes on code templates and learn to make code changes that would normally require a TD. TD\u2019s can establish layered templates for processes and write nodes and graphs. Developers can provide Nxt \u2018factory nodes\u2019 for using their tools without writing a custom UI.","title":"Discovery"},{"location":"reference/#functionalprocedural","text":"Nxt follows a functional model. It eschews object oriented inheritance with a layer model. This allows data to be inspected on the fly and easily read.","title":"Functional/Procedural"},{"location":"reference/#why-not-visual-programming","text":"Nxt differs from a visual programming environment where every function (math, concatenation, data, flow control) is wrapped up in a node. Fully visual programming environments result in sprawling graphs. While the functions are readable, they are not dense. Nxt displays code standard text notation but creates a visualization for the data. VP graphs can be tedious to construct. A simple operation can often require a dozen nodes but could be represented in 3 lines of code. VP graphs are code under the surface anyway, so to extend the functionality, you need to write code, or construct graphs of graphs. VP is a great tool for visualization of your data and flow, readability, experimentation, and discovery. NXT is half visual. Half code. Seeks to keep the best parts and remove the friction for more seasoned developers.","title":"Why not visual programming?"},{"location":"reference/#why-not-houdini","text":"Houdini is a tool for building tools. It\u2019s a visual processing engine. Can\u2019t it do all of this already? Houdini doesn\u2019t do layering Houdini is great, but maybe not the best at everything Artists have decades of experience in other tools Large segments of production already built around need to be built around Maya, Nuke, Unreal HDA\u2019s are black boxes and can be slow in host applications PDG is great, and expensive.","title":"Why not Houdini?"},{"location":"reference/#application-structure","text":"","title":"Application structure"},{"location":"tutorials/","text":"Examples Checkout our example content here , you'll find .nxt graphs demonstrating these same topics. If you're not quite sure how nxt fits into your workflow checkout our workflow and transition map here . Over there we explain nxt from different vantage points to help illuminate how nxt can work for you. Tutorials Getting started YouTube Playlist Introduction to tokens 01 Making and executing a node. Hello world. Make a node Add code Setup a token Use the output log 02 Adding and using attributes and tokens in code Naming Attribute types More on substitution Execution and Inheritance 03 Making and executing a series of nodes Executing nodes in sequence Pathing to nodes and attributes Execution options 04 Inheriting within a stack Stacks execution Inheritance within stacks Parent / unparent nodes Changing attribute display Additional notes on execution, history, build view Start points Break points Build view History view 05 Using attributes from other nodes Linking to other attrs Pathing to other attrs Instances 06 Node instances Instances Instance path Local vs instanced attributes Instances of instances More on attributes 07 Notes on renaming NXT doesn't rename anything automatically But it will recomp based on name 08 Attribute overloading and reverting Resolution order Node, parent, instance 09 Writing data to attributes from code Using self.attr Usign raw, resolved, cached view Layers 10 Layering and compositing Adding layers Layer display state Active layer Executing part of a layer Adding new attrs and overrides on a layer Contexts Sub-graphs Referencing builtin layers Calling sub-graphs Getting and using returns from sub-graphs Remote graphs Coming soon... Example Graph Walkthroughs Still pending Example: Mgear pre-post build Example: Maya hand rig Example: Nuke resize image sequence Example: Maya cloth attribute wedge and playblast","title":"Tutorials"},{"location":"tutorials/#examples","text":"Checkout our example content here , you'll find .nxt graphs demonstrating these same topics. If you're not quite sure how nxt fits into your workflow checkout our workflow and transition map here . Over there we explain nxt from different vantage points to help illuminate how nxt can work for you.","title":"Examples"},{"location":"tutorials/#tutorials","text":"Getting started YouTube Playlist","title":"Tutorials"},{"location":"tutorials/#introduction-to-tokens","text":"","title":"Introduction to tokens"},{"location":"tutorials/#01-making-and-executing-a-node-hello-world","text":"Make a node Add code Setup a token Use the output log","title":"01 Making and executing a node. Hello world."},{"location":"tutorials/#02-adding-and-using-attributes-and-tokens-in-code","text":"Naming Attribute types More on substitution","title":"02 Adding and using attributes and tokens in code"},{"location":"tutorials/#execution-and-inheritance","text":"","title":"Execution and Inheritance"},{"location":"tutorials/#03-making-and-executing-a-series-of-nodes","text":"Executing nodes in sequence Pathing to nodes and attributes Execution options","title":"03 Making and executing a series of nodes"},{"location":"tutorials/#04-inheriting-within-a-stack","text":"Stacks execution Inheritance within stacks Parent / unparent nodes Changing attribute display","title":"04 Inheriting within a stack"},{"location":"tutorials/#additional-notes-on-execution-history-build-view","text":"Start points Break points Build view History view","title":"Additional notes on execution, history, build view"},{"location":"tutorials/#05-using-attributes-from-other-nodes","text":"Linking to other attrs Pathing to other attrs","title":"05 Using attributes from other nodes"},{"location":"tutorials/#instances","text":"","title":"Instances"},{"location":"tutorials/#06-node-instances","text":"Instances Instance path Local vs instanced attributes Instances of instances","title":"06 Node instances"},{"location":"tutorials/#more-on-attributes","text":"","title":"More on attributes"},{"location":"tutorials/#07-notes-on-renaming","text":"NXT doesn't rename anything automatically But it will recomp based on name","title":"07 Notes on renaming"},{"location":"tutorials/#08-attribute-overloading-and-reverting","text":"Resolution order Node, parent, instance","title":"08 Attribute overloading and reverting"},{"location":"tutorials/#09-writing-data-to-attributes-from-code","text":"Using self.attr Usign raw, resolved, cached view","title":"09 Writing data to attributes from code"},{"location":"tutorials/#layers","text":"","title":"Layers"},{"location":"tutorials/#10-layering-and-compositing","text":"Adding layers Layer display state Active layer Executing part of a layer Adding new attrs and overrides on a layer","title":"10 Layering and compositing"},{"location":"tutorials/#contexts","text":"","title":"Contexts"},{"location":"tutorials/#sub-graphs","text":"Referencing builtin layers Calling sub-graphs Getting and using returns from sub-graphs","title":"Sub-graphs"},{"location":"tutorials/#remote-graphs","text":"Coming soon...","title":"Remote graphs"},{"location":"tutorials/#example-graph-walkthroughs","text":"Still pending","title":"Example Graph Walkthroughs"},{"location":"tutorials/#example-mgear-pre-post-build","text":"","title":"Example: Mgear pre-post build"},{"location":"tutorials/#example-maya-hand-rig","text":"","title":"Example: Maya hand rig"},{"location":"tutorials/#example-nuke-resize-image-sequence","text":"","title":"Example: Nuke resize image sequence"},{"location":"tutorials/#example-maya-cloth-attribute-wedge-and-playblast","text":"","title":"Example: Maya cloth attribute wedge and playblast"},{"location":"workflows/","text":"Workflows Nxt supports a particularly diverse cross-section of users with very different needs and working methods. Artist Code is just a click away for artists who know some scripting. Artists can tweak code written by a TD, and build on that example. Artists can also build their own graphs if a project doesn't require a TD. For example, they could change the height of a rig, or the image size for a render callback, or the directory where an asset is loaded. All without getting into the weeds on how the graph does the work. TD A TD\u2019s workflow bridges the gap between artists and developers. TDs need most of the deep functionality that a developer needs, but are also focused on speed when it\u2019s time to solve problems for artists. Black Box A Nxt graph can be packaged up as a pipeline tool and run in the background or on the farm. This might include: Rig build Asset publish Asset QC Farm submission Post render image processing VFX wedge Scene assembly Developer NXT provides an accessible front end to software and processes, allowing developers to spend more time on lower level tools. Transition Map This table will take concepts you are familiar with in other products and draw paralells to nxt concepts. OS NXT You refer to a directory and file by a path. For example, /projects/images/image.png This path points your program to the data in that file. You refer to a node and attribute by a path. For example /node/node2.attr This points NXT to the data in that source attribute. You can create a shortcut to another file. We know that it isn\u2019t the file, but a pointer to quickly work with that file. A token is a little like that shortcut. The token syntax is ${path} . A instance is also notionally similar to a shortcut in the most simple case. You can use relative paths, like ../scenes/object.obj . You can use relative node paths, like, ${../node2.attr} You refer to the drive root with / You refer to the stage root with / Note NXT node hierarchies process in a tree structure very similar to a directory structure. It starts at the root, executes any code in that node, then crawls through child nodes, compositing and executing any code it finds. Photoshop/ NLE NXT A basic photoshop layer contains an image. Add a new layer and you can see everything below until you paint on the higher layer in an area where there is already an image. Then the base layers become overridden. A NXT layer contains a set of nodes. Add a new layer and you can see everything below until you add a node on the higher layer that shares a name with a layer. Then the node on the lower layer is overridden. You can mute and solo layers to change what you see. You can mute and solo layers to change what is composited and executed You can overwrite a small portion of the image with a higher layer, or cover the entire layer. You can overwrite a single attribute, or overwrite the entire node. Maya NXT Maya nodes have attributes that hold data or connections to other nodes. NXT nodes have properties that hold data or pointers to other nodes or properties Maya draws connections between connected attributes. NXT draws two types of connections. 1. Node execution 2. Attribute connections Maya transform nodes exist in a hierarchy and inherit the transforms of their parent. NXT nodes inherit properties and values of parent nodes. Maya executes using a DAG. NXT executes using a DAG and then a tree. A Maya instance is a pointer to a shape, but that shape can have any transform. Any change to the shape propagates to all the instances. A NXT instance is a pointer to a node, and any attributes on that node can be selectively overridden. A change to the original node propagates to all the instances A Maya reference loads an external file, and then attributes and connections can be overridden or added ( but not deleted ), leaving the source file untouched. A NXT layer loads an external file, and then attributes and connections can be overridden or added ( but not deleted ), leaving the source file untouched. To make substantial changes to a Maya reference, you would change the original file, or import the file and \u2018own\u2019 it in your scene. A NXT node can be localized and similar to importing. Values are edited via channel box or attribute editor Values are edited via property editor UI: navigation, renaming, node connections, 123 hotkeys, qwer hotkeys, Nuke NXT Nuke processes a graph of nodes. Each node can manipulate, add, or remove image data in specific channels. NXT processes a graph of node trees. Any node can access or overwrite an inherited attribute. Houdini NXT Houdini SOP nodes pass a table of attributes to subsequent nodes that can be modified, added or deleted. NXT works in a similar way with it\u2019s inheritance tree. Any child node can access an inherited attribute, visualized via spreadsheet. Any child node can access an inherited attribute, visualized via resolved/cached view. Node paths follow OS conventions Node paths follow OS conventions Blueprint/Bifrost/Ice/VEX NXT These have a node for every function; type conversion, flow control, random generation. NXT uses nodes and graphs to represent the data and tree execution, but the logic, flow control, and execution is all code.","title":"Workflows"},{"location":"workflows/#workflows","text":"Nxt supports a particularly diverse cross-section of users with very different needs and working methods.","title":"Workflows"},{"location":"workflows/#artist","text":"Code is just a click away for artists who know some scripting. Artists can tweak code written by a TD, and build on that example. Artists can also build their own graphs if a project doesn't require a TD. For example, they could change the height of a rig, or the image size for a render callback, or the directory where an asset is loaded. All without getting into the weeds on how the graph does the work.","title":"Artist"},{"location":"workflows/#td","text":"A TD\u2019s workflow bridges the gap between artists and developers. TDs need most of the deep functionality that a developer needs, but are also focused on speed when it\u2019s time to solve problems for artists.","title":"TD"},{"location":"workflows/#black-box","text":"A Nxt graph can be packaged up as a pipeline tool and run in the background or on the farm. This might include: Rig build Asset publish Asset QC Farm submission Post render image processing VFX wedge Scene assembly","title":"Black Box"},{"location":"workflows/#developer","text":"NXT provides an accessible front end to software and processes, allowing developers to spend more time on lower level tools.","title":"Developer"},{"location":"workflows/#transition-map","text":"This table will take concepts you are familiar with in other products and draw paralells to nxt concepts. OS NXT You refer to a directory and file by a path. For example, /projects/images/image.png This path points your program to the data in that file. You refer to a node and attribute by a path. For example /node/node2.attr This points NXT to the data in that source attribute. You can create a shortcut to another file. We know that it isn\u2019t the file, but a pointer to quickly work with that file. A token is a little like that shortcut. The token syntax is ${path} . A instance is also notionally similar to a shortcut in the most simple case. You can use relative paths, like ../scenes/object.obj . You can use relative node paths, like, ${../node2.attr} You refer to the drive root with / You refer to the stage root with / Note NXT node hierarchies process in a tree structure very similar to a directory structure. It starts at the root, executes any code in that node, then crawls through child nodes, compositing and executing any code it finds. Photoshop/ NLE NXT A basic photoshop layer contains an image. Add a new layer and you can see everything below until you paint on the higher layer in an area where there is already an image. Then the base layers become overridden. A NXT layer contains a set of nodes. Add a new layer and you can see everything below until you add a node on the higher layer that shares a name with a layer. Then the node on the lower layer is overridden. You can mute and solo layers to change what you see. You can mute and solo layers to change what is composited and executed You can overwrite a small portion of the image with a higher layer, or cover the entire layer. You can overwrite a single attribute, or overwrite the entire node. Maya NXT Maya nodes have attributes that hold data or connections to other nodes. NXT nodes have properties that hold data or pointers to other nodes or properties Maya draws connections between connected attributes. NXT draws two types of connections. 1. Node execution 2. Attribute connections Maya transform nodes exist in a hierarchy and inherit the transforms of their parent. NXT nodes inherit properties and values of parent nodes. Maya executes using a DAG. NXT executes using a DAG and then a tree. A Maya instance is a pointer to a shape, but that shape can have any transform. Any change to the shape propagates to all the instances. A NXT instance is a pointer to a node, and any attributes on that node can be selectively overridden. A change to the original node propagates to all the instances A Maya reference loads an external file, and then attributes and connections can be overridden or added ( but not deleted ), leaving the source file untouched. A NXT layer loads an external file, and then attributes and connections can be overridden or added ( but not deleted ), leaving the source file untouched. To make substantial changes to a Maya reference, you would change the original file, or import the file and \u2018own\u2019 it in your scene. A NXT node can be localized and similar to importing. Values are edited via channel box or attribute editor Values are edited via property editor UI: navigation, renaming, node connections, 123 hotkeys, qwer hotkeys, Nuke NXT Nuke processes a graph of nodes. Each node can manipulate, add, or remove image data in specific channels. NXT processes a graph of node trees. Any node can access or overwrite an inherited attribute.","title":"Transition Map"},{"location":"workflows/#_1","text":"Houdini NXT Houdini SOP nodes pass a table of attributes to subsequent nodes that can be modified, added or deleted. NXT works in a similar way with it\u2019s inheritance tree. Any child node can access an inherited attribute, visualized via spreadsheet. Any child node can access an inherited attribute, visualized via resolved/cached view. Node paths follow OS conventions Node paths follow OS conventions","title":""},{"location":"workflows/#_2","text":"Blueprint/Bifrost/Ice/VEX NXT These have a node for every function; type conversion, flow control, random generation. NXT uses nodes and graphs to represent the data and tree execution, but the logic, flow control, and execution is all code.","title":""}]}